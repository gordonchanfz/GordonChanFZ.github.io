(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{1586:function(t,a,s){"use strict";s.r(a);var e=s(3),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("分布式算法保证分布式集群环境的一致性")]),t._v(" "),a("h3",{attrs:{id:"分布式快照为什么难"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式快照为什么难"}},[t._v("#")]),t._v(" "),a("strong",[t._v("分布式快照为什么难？")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("系统状态是不断变化的，各个Process时间也不是完全一致的；")])]),t._v(" "),a("li",[a("p",[t._v("不能让系统停下来做快照，快照对系统的负面影响应该尽量小；")])]),t._v(" "),a("li",[a("p",[t._v("想象给一大群奔跑的羊拍照，由于羊群太大，一张照片没法捕捉完整，需要好几张照片合成，但是羊群不会停下来，如何能够获得一张有意义的照片？比如，每一只羊正好都只出现了一次？如果羊倌在回家前数数羊是不是少了，这种快照就是有意义的。虽然不是照片上所有的羊的位置都是同一个物理时刻的。")])])]),t._v(" "),a("h1",{attrs:{id:"chandy-lamport-algorithm分布式快照"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chandy-lamport-algorithm分布式快照"}},[t._v("#")]),t._v(" Chandy-Lamport algorithm分布式快照")]),t._v(" "),a("h2",{attrs:{id:"_2-分布式系统模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-分布式系统模型"}},[t._v("#")]),t._v(" 2. 分布式系统模型")]),t._v(" "),a("p",[a("strong",[t._v("2.1 分布式系统的抽象模型")])]),t._v(" "),a("ul",[a("li",[t._v("分布式系统由一系列Processes和通信Channel组成；")]),t._v(" "),a("li",[t._v("认为每个Channel是有向的(一个双向连接可以认为是两个Channel);")]),t._v(" "),a("li",[t._v("整个系统构成了一个有向图： Process是图的顶点，Channel是图的边；")]),t._v(" "),a("li",[t._v("进程可以自己执行运算，还可以Send/Recv消息；")]),t._v(" "),a("li",[t._v("进程可以记录状态(进程当前状态、已发送的消息，已接收的消息)。")])]),t._v(" "),a("p",[a("strong",[t._v("2.2 对Channel的假设")])]),t._v(" "),a("ul",[a("li",[t._v("不会乱序 ，后面会看到，Snapshot Marker与其他msg之间的顺序，是不能打乱的；")]),t._v(" "),a("li",[t._v("没有错误。")])]),t._v(" "),a("p",[a("strong",[t._v("2.3 Channel的State")])]),t._v(" "),a("ul",[a("li",[t._v("一个Channel上已被接收的消息，是已发送消息的一个子序列(Subsequence)；")]),t._v(" "),a("li",[a("strong",[t._v("Channel的状态，用“已发送的消息” 减去 “已被接收的消息”表示，即： 已发 - 已收。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("The state of a channel is the sequence of messages sent along the channel, excluding the messages received along the channel")])]),t._v(" "),a("ul",[a("li",[t._v("Channel状态是由接收者来记录的。")])]),t._v(" "),a("p",[a("strong",[t._v("2.4 Process的State")])]),t._v(" "),a("p",[a("img",{attrs:{src:s(726),alt:"image-20230304203217613"}})]),t._v(" "),a("p",[a("strong",[t._v("2.5 分布式系统的Global State")])]),t._v(" "),a("p",[a("img",{attrs:{src:s(727),alt:"image-20230304203248838"}})]),t._v(" "),a("p",[a("strong",[t._v("2.6 一个简单例子 - 单令牌保护系统")])]),t._v(" "),a("p",[a("img",{attrs:{src:s(728),alt:"image-20230304203546710"}})]),t._v(" "),a("p",[a("img",{attrs:{src:s(729),alt:"img"}})]),t._v(" "),a("p",[t._v("注意这个例子中，每个状态都维护了一个不变式： token一直在p, q, c或者c'之一上。不会在某个状态出现两个 token，token也不会消失。在后续的快照算法中，会以这个简单的分布式系统为例，说明快照算法可能出现的问题。")]),t._v(" "),a("h2",{attrs:{id:"_3-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-算法"}},[t._v("#")]),t._v(" 3. 算法")]),t._v(" "),a("p",[a("strong",[t._v("3.1 算法是怎么来的？")])]),t._v(" "),a("p",[a("strong",[t._v("3.1.1 初始思路")])]),t._v(" "),a("ul",[a("li",[t._v("每个Process负责记录自己的状态；")]),t._v(" "),a("li",[t._v("每个Channel由其两端的Process分别记录(已发和已收)；")]),t._v(" "),a("li",[t._v('不能保证每个process严格在同一个时刻(instant)记录状态，但是最终形成的需要是个**"有意义"状态**；')]),t._v(" "),a("li",[t._v("快照需要被叠加(SuperImpose)到已有计算上，即尽量不干扰系统固有的计算。")])]),t._v(" "),a("p",[a("strong",[t._v("3.1.2 容易出现的问题分析")])]),t._v(" "),a("p",[a("strong",[t._v("Example 3.1 的快照过程")])]),t._v(" "),a("p",[t._v("这里先假设每个进程可以原子地记录自己的状态，Channel的状态也可以被原子地记录(实际实现要复杂些)。考虑下图中的记录步骤：最终记录的状态是："),a("strong",[t._v("p和c都认为自己有token")]),t._v("。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(730),alt:"image-20230624004252279"}})]),t._v(" "),a("p",[a("strong",[t._v("出现两个token问题原因分析")])]),t._v(" "),a("p",[a("img",{attrs:{src:s(731),alt:"image-20230304204206649"}})]),t._v(" "),a("p",[a("img",{attrs:{src:s(732),alt:"img"}})]),t._v(" "),a("p",[a("img",{attrs:{src:s(733),alt:"image-20230304205226001"}})]),t._v(" "),a("p",[a("strong",[t._v("3.2 算法要点")])]),t._v(" "),a("p",[a("strong",[t._v("3.2.1 算法的规则")])]),t._v(" "),a("p",[a("img",{attrs:{src:s(734),alt:"image-20230304205918118"}})]),t._v(" "),a("p",[a("strong",[t._v("3.2.2 算法的结束")])]),t._v(" "),a("ul",[a("li",[t._v("结束的含义：所有的 Process和Chan，都完成快照状态记录;")]),t._v(" "),a("li",[t._v("如果是个强连通图，那么从任意一个节点开始，都能在有限时间内结束；")]),t._v(" "),a("li",[t._v("如果不是强连通图，但是所有节点可达，那么从某些指定节点开始，也能在有限时间内结束。")]),t._v(" "),a("li",[a("img",{attrs:{src:s(735),alt:"image-20230304211330299"}})])]),t._v(" "),a("p",[a("img",{attrs:{src:s(736),alt:"image-20230304211617569"}})]),t._v(" "),a("p",[a("img",{attrs:{src:s(737),alt:"image-20230304214930505"}})]),t._v(" "),a("p",[a("img",{attrs:{src:s(738),alt:"image-20230304214831312"}})]),t._v(" "),a("p",[a("strong",[t._v("3.3 结合token的例子讨论下算法")])]),t._v(" "),a("p",[a("strong",[t._v("3.3.1")]),t._v(" 假设p要给q发送token，且p在q之前记录状态，随后发送了Marker给q")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("如果q收到的第一个Marker来自p，那么q的状态记录中包含了p进行记录之前的所有消息；")])]),t._v(" "),a("li",[a("p",[t._v("如果q收到的第一个Marker不是来自p，那么q等待收到p的Marker才算完成chan的状态记录。即生成的chan状态记录中包含了p在record之前的所有消息(在p record时，这些消息可能在chan中，也可能已经被q接收完)。")])])]),t._v(" "),a("p",[t._v("对于上面的例子，考虑p是发送token给q，p记录快照的时间点可以是：(A) In-p; (B). In-chan; (C). In-q。无论如何，记录的快照整体应该包含且只包含一个 token。")]),t._v(" "),a("p",[a("img",{attrs:{src:s(739),alt:"image-20230624004430796"}})]),t._v(" "),a("p",[t._v("3.3.2 假设p给q发送token, 但是q先于p 记录状态")]),t._v(" "),a("ul",[a("li",[t._v("如果q在收到token后才开始记录，即q记录时已经token传递完成，那么二者记录的都是token已经传递完成的一致状态;")]),t._v(" "),a("li",[t._v("如果q在记录时，token在路上(in-chan)，那么q记录的状态，不含token，随后发送marker给p，但是此时q并没有完成chan的的快照记录；随后，p 记录自己的状态，并发送marker给 q，q才完成chan的状态记录。最终记录的是token出于in-chan状态，是个正确的状态记录。")])]),t._v(" "),a("p",[a("img",{attrs:{src:s(740),alt:"image-20230624004418197"}})]),t._v(" "),a("p",[t._v("与前面相比，为什么这里q有了in-chan? 因为 token位于q收到的两个Marker之间。而不是首个Maker之前。")]),t._v(" "),a("p",[a("strong",[t._v("总结")])]),t._v(" "),a("ul",[a("li",[t._v("无论p还是q先开始记录，最终都能得到一致的状态。")]),t._v(" "),a("li",[t._v("在q收到首个Marker之前收到的token，计入了q自身的状态(已接收)；")]),t._v(" "),a("li",[t._v("在 q收到首个Marker之后收到的token，计入了 chan 的状态。")])]),t._v(" "),a("p",[t._v("应用：")]),t._v(" "),a("p",[t._v("Flink checkpoint底层分布式快照算法")]),t._v(" "),a("p",[t._v("参考https://zhuanlan.zhihu.com/p/96045864")]),t._v(" "),a("h1",{attrs:{id:"paxos一致性算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paxos一致性算法"}},[t._v("#")]),t._v(" Paxos一致性算法")]),t._v(" "),a("p",[t._v("应用：")]),t._v(" "),a("p",[t._v("zk")])])}),[],!1,null,null,null);a.default=n.exports},726:function(t,a,s){t.exports=s.p+"assets/img/image-20230304203217613.e3397d1f.png"},727:function(t,a,s){t.exports=s.p+"assets/img/image-20230304203248838.c2b01846.png"},728:function(t,a,s){t.exports=s.p+"assets/img/image-20230304203546710.7a226168.png"},729:function(t,a,s){t.exports=s.p+"assets/img/v2-72efe1a09fc6de4ad90d1502fd1d840d_r.70dea35c.jpg"},730:function(t,a,s){t.exports=s.p+"assets/img/image-20230624004252279.ef91d0f5.png"},731:function(t,a,s){t.exports=s.p+"assets/img/image-20230304204206649.52ce1cb8.png"},732:function(t,a,s){t.exports=s.p+"assets/img/v2-76878a16655cd2c9324895353ef70423_r.f6a76e67.jpg"},733:function(t,a,s){t.exports=s.p+"assets/img/image-20230304205226001.020465d3.png"},734:function(t,a,s){t.exports=s.p+"assets/img/image-20230304205918118.4671a082.png"},735:function(t,a,s){t.exports=s.p+"assets/img/image-20230304211330299.69c60cf5.png"},736:function(t,a,s){t.exports=s.p+"assets/img/image-20230304211617569.1b4d57da.png"},737:function(t,a,s){t.exports=s.p+"assets/img/image-20230304214930505.a2de69d2.png"},738:function(t,a,s){t.exports=s.p+"assets/img/image-20230304214831312.f37f8972.png"},739:function(t,a,s){t.exports=s.p+"assets/img/image-20230624004430796.f6d2a655.png"},740:function(t,a,s){t.exports=s.p+"assets/img/image-20230624004418197.a0327033.png"}}]);
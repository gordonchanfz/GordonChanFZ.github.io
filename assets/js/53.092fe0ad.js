(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{1603:function(e,l,v){"use strict";v.r(l);var i=v(3),_=Object(i.a)({},(function(){var e=this,l=e._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"redis操作命令锦集"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#redis操作命令锦集"}},[e._v("#")]),e._v(" redis操作命令锦集")]),e._v(" "),l("p",[e._v("本章节给大家规整一下redis中常用的操作命令")]),e._v(" "),l("h2",{attrs:{id:"redis中五种数据类型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#redis中五种数据类型"}},[e._v("#")]),e._v(" redis中五种数据类型")]),e._v(" "),l("ul",[l("li",[l("ol",[l("li",[e._v("字符串 String    ----"),l("strong",[e._v("重点")])])]),e._v(" "),l("ul",[l("li",[e._v("特点: 存储所有的字符和字符串")]),e._v(" "),l("li",[e._v("应用场景:  做缓存使用")])])]),e._v(" "),l("li",[l("ol",{attrs:{start:"2"}},[l("li",[e._v("哈希  hash")])]),e._v(" "),l("ul",[l("li",[e._v("特点: 相当于java中hashMap集合")]),e._v(" "),l("li",[e._v("应用场景: 可以存储javaBean对象, 此种使用场景不多,可被String替代")])])]),e._v(" "),l("li",[l("ol",{attrs:{start:"3"}},[l("li",[e._v("list集合")])]),e._v(" "),l("ul",[l("li",[e._v("特点: 相当于java中linkList, 是一个链表的结构")]),e._v(" "),l("li",[e._v("应用场景: 做任务队列,\n"),l("ul",[l("li",[e._v("在java中客户端提供了线程安全获取集合数据的方式")])])])])]),e._v(" "),l("li",[l("ol",{attrs:{start:"4"}},[l("li",[e._v("set 集合")])]),e._v(" "),l("ul",[l("li",[e._v("特点: 唯一, 无序")]),e._v(" "),l("li",[e._v("应用场景: 集合运算\n"),l("ul",[l("li",[e._v("例如去重复的操作")])])])])]),e._v(" "),l("li",[l("ol",{attrs:{start:"5"}},[l("li",[e._v("有序set集合: sorted set")])]),e._v(" "),l("ul",[l("li",[e._v("特点:唯一, 有序")]),e._v(" "),l("li",[e._v("应用场景: 一般用来做排行榜")])])])]),e._v(" "),l("h2",{attrs:{id:"redis中string类型相关命令"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#redis中string类型相关命令"}},[e._v("#")]),e._v(" redis中String类型相关命令")]),e._v(" "),l("ul",[l("li",[e._v("赋值:  set key value\n"),l("ul",[l("li",[e._v("设定key持有指定的字符串value，如果该key存在则进行覆盖操作。总是返回”OK”")])])]),e._v(" "),l("li",[e._v("取值: get key\n"),l("ul",[l("li",[e._v("获取key的value。如果与该key关联的value不是String类型，redis将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回(nil)")])])]),e._v(" "),l("li",[e._v("删除: del key\n"),l("ul",[l("li",[e._v("删除指定的key")])])]),e._v(" "),l("li",[e._v("数值增减:\n"),l("ul",[l("li",[e._v("增减值: incr key\n"),l("ul",[l("li",[e._v("将指定的key的value原子性的递增1.如果该key不存在，其初始值为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。")])])]),e._v(" "),l("li",[e._v("减少值: decr key\n"),l("ul",[l("li",[e._v("将指定的key的value原子性的递减1.如果该key不存在，其初始值为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息")])])]),e._v(" "),l("li",[e._v("增加固定的值: incrby key increment\n"),l("ul",[l("li",[e._v("将指定的key的value原子性增加increment，如果该key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成整型，如hello则失败并返回错误信息")])])]),e._v(" "),l("li",[e._v("减少固定的值: decrby key decrement\n"),l("ul",[l("li",[e._v("将指定的key的value原子性减少decrement，如果该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能转成整型，如hello则失败并返回错误信息")])])])])]),e._v(" "),l("li",[e._v("拼接value值:  append key  value\n"),l("ul",[l("li",[e._v("拼凑字符串。如果该key存在，则在原有的value后追加该值；如果该key不存在，则重新创建一个key|value")])])]),e._v(" "),l("li",[e._v("为key中内容设置有效时长:\n"),l("ul",[l("li",[e._v("为新创建的key设置时长\n"),l("ul",[l("li",[e._v("setex key seconds value")])])]),e._v(" "),l("li",[e._v("为已有的key设置有效时长\n"),l("ul",[l("li",[e._v("expire key seconds")])])])])]),e._v(" "),l("li",[e._v("判断key是否存在: exists key\n"),l("ul",[l("li",[e._v("返回1 表示存在, 返回0 表示不存在")])])]),e._v(" "),l("li",[e._v("获取key还剩余有效时长:  ttl  key\n"),l("ul",[l("li",[e._v("特殊: 返回-1 表示永久有效 返回-2 表示不存在")])])])]),e._v(" "),l("h2",{attrs:{id:"redis中hash类型的相关命令"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#redis中hash类型的相关命令"}},[e._v("#")]),e._v(" redis中hash类型的相关命令")]),e._v(" "),l("ul",[l("li",[e._v("存值: hset key field value\n"),l("ul",[l("li",[e._v("key为一个字符串, value类似于map,同样有一个field和value")])])]),e._v(" "),l("li",[e._v("取值:\n"),l("ul",[l("li",[e._v("获取指定key的field的值:  hget key field")]),e._v(" "),l("li",[e._v("获取指定key的多个field值: hmget key fields")]),e._v(" "),l("li",[e._v("获取指定key中的所有的field与value的值:  hgetall key")]),e._v(" "),l("li",[e._v("获取指定key中map的所有的field: hkeys key")]),e._v(" "),l("li",[e._v("获取指定key中map的所有的value: hvals key")])])]),e._v(" "),l("li",[e._v("删除:\n"),l("ul",[l("li",[e._v("hdel key field [field … ] ：可以删除一个或多个字段，返回值是被删除的字段个数")]),e._v(" "),l("li",[e._v("del key ：删除整个内容")])])]),e._v(" "),l("li",[e._v("增加数字:\n"),l("ul",[l("li",[e._v("hincrby key field number：为某个key的某个属性增加值")])])]),e._v(" "),l("li",[e._v("判断某个key中的filed是否存在: hexists key field\n"),l("ul",[l("li",[e._v("返回 0表示没有,  返回1 表示有")])])]),e._v(" "),l("li",[e._v("获取key中所包含的field的数量: hlen key")])]),e._v(" "),l("h2",{attrs:{id:"redis中list集合类型的相关命令"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#redis中list集合类型的相关命令"}},[e._v("#")]),e._v(" redis中list集合类型的相关命令")]),e._v(" "),l("p",[e._v("redis的中的list集合类似于java中的linkedlist集合,此集合也是队列的一种, 支持向两端操作")]),e._v(" "),l("ul",[l("li",[e._v("添加:\n"),l("ul",[l("li",[e._v("从左侧添加: lpush key values[value1 value2…]\n"),l("ul",[l("li",[e._v("在指定的key所关联的list的头部插入所有的values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。")])])]),e._v(" "),l("li",[e._v("从右侧添加: rpush key values[value1、value2…]\n"),l("ul",[l("li",[e._v("在该list的尾部添加元素")])])])])]),e._v(" "),l("li",[e._v("查看列表 : lrange key start end\n"),l("ul",[l("li",[e._v("获取链表中从start到end的元素的值，start、end从0开始计数；end可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推…")])])]),e._v(" "),l("li",[e._v("删除(弹出):\n"),l("ul",[l("li",[e._v("从左侧弹出:lpop key\n"),l("ul",[l("li",[e._v("返回并弹出指定的key关联的链表中的第一个元素，即头部元素。如果该key不存在，返回nil；若key存在，则返回链表的头部元素")])])]),e._v(" "),l("li",[e._v("从右侧弹出: rpop key\n"),l("ul",[l("li",[e._v("从尾部弹出元素")])])])])]),e._v(" "),l("li",[e._v("获取列表中元素的个数: llen key\n"),l("ul",[l("li",[e._v("返回指定的key关联的链表中的元素的数量")])])]),e._v(" "),l("li",[e._v("向指定的key插入数据, 仅在key存在时插入, 不存在不插入\n"),l("ul",[l("li",[e._v("从左侧:lpushx key value")]),e._v(" "),l("li",[e._v("从右侧: rpushx key value")])])]),e._v(" "),l("li",[e._v("lrem key count value:\n"),l("ul",[l("li",[e._v("删除count个值为value的元素，如果count大于0，从头向尾遍历并删除count个值为value的元素，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素")])])]),e._v(" "),l("li",[e._v("lset key index value:\n"),l("ul",[l("li",[e._v("设置链表中的index的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素。操作链表的脚标不存在则抛异常。")])])]),e._v(" "),l("li",[e._v("linsert key before|after pivot value\n"),l("ul",[l("li",[e._v("在pivot元素前或者后插入value这个元素。")])])]),e._v(" "),l("li",[e._v("rpoplpush resource destination\n"),l("ul",[l("li",[e._v("将链表中的尾部元素弹出并添加到头部。[循环操作]")]),e._v(" "),l("li",[e._v("rpoplpush  list1 list2 （把list1尾部的元素，加入到list2头部的元素里）")])])]),e._v(" "),l("li",[e._v("注意:我们index是从0开始， 最后一位的index是用-1表示。")])]),e._v(" "),l("h2",{attrs:{id:"redis中的set集合的相关命令操作"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#redis中的set集合的相关命令操作"}},[e._v("#")]),e._v(" redis中的set集合的相关命令操作")]),e._v(" "),l("ul",[l("li",[e._v("添加: sadd key values[value1、value2…]\n"),l("ul",[l("li",[e._v("向set中添加数据，如果该key的值已有则不会重复添加")])])]),e._v(" "),l("li",[e._v("删除: srem key members[member1、member2…]\n"),l("ul",[l("li",[e._v("删除set中指定的成员")])])]),e._v(" "),l("li",[e._v("获取所有的元素: smembers key\n"),l("ul",[l("li",[e._v("获取set中所有的成员")])])]),e._v(" "),l("li",[e._v("判断元素是否存在: sismember key member\n"),l("ul",[l("li",[e._v("判断参数中指定的成员是否在该set中，1表示存在，0表示不存在或者该key本身就不存在。（无论集合中有多少元素都可以极速的返回结果）")])])]),e._v(" "),l("li",[e._v("集合的差集运算: sdiff key1 key2…\n"),l("ul",[l("li",[e._v("返回key1与key2中相差的成员，而且与key的顺序有关。那个在前, 返回那个key对应的差集")])])]),e._v(" "),l("li",[e._v("集合的交集运算:sinter key1 key2 key3…\n"),l("ul",[l("li",[e._v("返回交集, 两个key都有的")])])]),e._v(" "),l("li",[e._v("集合的并集运算:sunion key1 key2 key3…\n"),l("ul",[l("li",[e._v("返回并集")])])]),e._v(" "),l("li",[e._v("获取set中成员的数量:\n"),l("ul",[l("li",[e._v("scard key")])])]),e._v(" "),l("li",[e._v("随机返回set中的一个成员:\n"),l("ul",[l("li",[e._v("srandmember key")])])]),e._v(" "),l("li",[e._v("将key1、key2相差的成员存储在destination上:\n"),l("ul",[l("li",[e._v("sdiffstore destination key1 key2…")])])]),e._v(" "),l("li",[e._v("将返回的交集存储在destination上:\n"),l("ul",[l("li",[e._v("sinterstore destination key[key…]")])])]),e._v(" "),l("li",[e._v("将返回的并集存储在destination上:\n"),l("ul",[l("li",[e._v("sunionstore destination key[key…]")])])])]),e._v(" "),l("h2",{attrs:{id:"redis中的sortedset-zset-集合的相关操作"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#redis中的sortedset-zset-集合的相关操作"}},[e._v("#")]),e._v(" redis中的sortedset（zset）集合的相关操作:")]),e._v(" "),l("ul",[l("li",[l("p",[e._v("添加数据: zadd key score member")]),e._v(" "),l("ul",[l("li",[e._v("将所有成员以及该成员的分数存放到sorted-set中。如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素")])])]),e._v(" "),l("li",[l("p",[e._v("获得元素:")]),e._v(" "),l("ul",[l("li",[e._v("zscore key member: 返回指定元素的值")]),e._v(" "),l("li",[e._v("zcard key: 获取集合中的成员数量")])])]),e._v(" "),l("li",[l("p",[e._v("删除元素:zrem key member[member…]")]),e._v(" "),l("ul",[l("li",[e._v("移除集合中指定的成员，可以指定多个成员。")])])]),e._v(" "),l("li",[l("p",[e._v("zrank key member:")]),e._v(" "),l("ul",[l("li",[e._v("返回成员在集合中的排名。（从小到大）")])])]),e._v(" "),l("li",[l("p",[e._v("zrevrank key member")]),e._v(" "),l("ul",[l("li",[e._v("返回成员在集合中的排名。（从大到小）")])])]),e._v(" "),l("li",[l("p",[e._v("zincrby key 增加分数 member:")]),e._v(" "),l("ul",[l("li",[e._v("设置指定成员的增加的分数。返回值是更改后的分数 ...")])])]),e._v(" "),l("li",[l("p",[e._v("范围查询:")]),e._v(" "),l("ul",[l("li",[e._v("zrange key start end [withscores]: 获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数")]),e._v(" "),l("li",[e._v("zrevrange key start stop [withscores]: 按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）")])])]),e._v(" "),l("li",[l("p",[e._v("zremrangebyrank key start stop: 按照排名范围删除元素")])]),e._v(" "),l("li",[l("p",[e._v("zremrangebyscore key min max: 按照分数范围删除元素")])]),e._v(" "),l("li",[l("p",[e._v("zrangebyscore key min max [withscores][limit offset count]:")]),e._v(" "),l("ul",[l("li",[e._v("返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数；[limit offset count]：offset，表明从脚标为offset的元素开始并返回count个成员a")])])]),e._v(" "),l("li",[l("p",[e._v("zcount key min max:")]),e._v(" "),l("ul",[l("li",[e._v("获取分数在[min,max]之间的成员")])])])])])}),[],!1,null,null,null);l.default=_.exports}}]);